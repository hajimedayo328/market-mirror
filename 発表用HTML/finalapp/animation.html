<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Prism of Distortion - Colorful Feedback</title>
    <style>
        /* * デザインコンセプト: 
         * Apple/Stripeライクな極めてクリーンでモダンなセットアップ。
         * 余計なUIは一切排除し、没入感を高める。
         */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #ffffff; /* 純白の背景 */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        /* プレゼンテーション待機画面用の控えめなタイトルオーバーレイ */
        .overlay {
            position: absolute;
            bottom: 40px;
            left: 40px;
            pointer-events: none;
            opacity: 0.8;
            color: #1a1a1a;
            mix-blend-mode: multiply;
        }
        
        .overlay h1 {
            font-size: 14px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            font-weight: 500;
            margin: 0;
            color: #888;
        }
        
        .overlay p {
            font-size: 24px;
            font-weight: 300;
            margin: 5px 0 0 0;
            letter-spacing: -0.02em;
        }
    </style>
</head>
<body>

    <!-- プレゼン待機画面としてのメタ情報 -->
    <div class="overlay">
        <h1>Concept</h1>
        <p>Diverse Feedback Loop</p>
    </div>

    <canvas id="heroCanvas"></canvas>

<script>
/**
 * THE PRISM OF DISTORTION - COLORFUL FEEDBACK VERSION
 * * Huge Yellow Needle (Idea) -> Giant Clockwise Engine -> 50 Random Targets (Shuffled) -> Colorful Reflection
 */

class Utils {
    static random(min, max) {
        return Math.random() * (max - min) + min;
    }

    static distance(x1, y1, x2, y2) {
        const dx = x1 - x2;
        const dy = y1 - y2;
        return Math.sqrt(dx * dx + dy * dy);
    }
}

/**
 * Class: Node (The Persona)
 * 右側に配置される点。色はランダムでごちゃ混ぜ。
 */
class Node {
    constructor(x, y) {
        this.baseX = x;
        this.baseY = y;
        this.x = x;
        this.y = y;
        
        this.vx = 0;
        this.vy = 0;
        this.friction = 0.92;
        this.springFactor = 0.05;
        
        this.baseRadius = 3;
        this.radius = this.baseRadius;
        this.targetRadius = this.baseRadius;
        
        // 色をランダム生成（ごちゃ混ぜ）
        const hue = Math.random() * 360;
        const sat = Utils.random(60, 90);
        const lig = Utils.random(50, 70);
        
        const rgb = this.hslToRgb(hue / 360, sat / 100, lig / 100);
        
        this.baseColor = { r: rgb[0], g: rgb[1], b: rgb[2] };
        this.targetColor = { ...this.baseColor };
        this.currentColor = { ...this.baseColor };
    }
    
    // Helper
    hslToRgb(h, s, l){
        let r, g, b;
        if(s === 0){
            r = g = b = l; 
        }else{
            const hue2rgb = (p, q, t) => {
                if(t < 0) t += 1;
                if(t > 1) t -= 1;
                if(t < 1/6) return p + (q - p) * 6 * t;
                if(t < 1/2) return q;
                if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    hit() {
        // ヒット時は白っぽく発光してから元の色に戻る
        this.targetColor = { r: 255, g: 255, b: 255 };
        
        const force = Utils.random(3, 8);
        const angle = Utils.random(0, Math.PI * 2);

        this.vx += Math.cos(angle) * force;
        this.vy += Math.sin(angle) * force;
        this.radius = 8;
    }

    update() {
        const dx = this.targetRadius - this.radius;
        this.radius += dx * 0.1;

        const ax = (this.baseX - this.x) * this.springFactor;
        const ay = (this.baseY - this.y) * this.springFactor;

        this.vx += ax;
        this.vy += ay;
        this.vx *= this.friction;
        this.vy *= this.friction;
        this.x += this.vx;
        this.y += this.vy;

        // 色の補間
        const colorLerpSpeed = 0.1;
        this.currentColor.r += (this.targetColor.r - this.currentColor.r) * colorLerpSpeed;
        this.currentColor.g += (this.targetColor.g - this.currentColor.g) * colorLerpSpeed;
        this.currentColor.b += (this.targetColor.b - this.currentColor.b) * colorLerpSpeed;

        // 元の色に戻る
        if (Math.abs(this.targetColor.r - this.baseColor.r) > 1) {
             const returnSpeed = 0.05;
             this.targetColor.r += (this.baseColor.r - this.targetColor.r) * returnSpeed;
             this.targetColor.g += (this.baseColor.g - this.targetColor.g) * returnSpeed;
             this.targetColor.b += (this.baseColor.b - this.targetColor.b) * returnSpeed;
        }
        
        if (this.targetRadius > this.baseRadius) {
            this.targetRadius -= 0.5;
        }
    }

    draw(ctx) {
        if (this.radius > this.baseRadius + 0.5) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, 0.3)`;
            ctx.fill();
        }

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, 1)`;
        ctx.fill();
    }
}

/**
 * Class: Lens (The Core Engine)
 * 巨大化、時計回り統一。
 */
class Lens {
    constructor(cx, cy) {
        this.cx = cx;
        this.cy = cy;
        this.radius = 160; 
        this.angle = 0;
        
        // 内部リング：すべて正のspeed（時計回り）
        this.rings = [
            { r: 50, speed: 0.015, angle: 0, width: 2 },
            { r: 90, speed: 0.01, angle: 0, width: 1.5 },
            { r: 130, speed: 0.005, angle: 0, width: 4 }
        ];
    }

    update(cx, cy) {
        this.cx = cx;
        this.cy = cy;
        
        // 全体も時計回り
        this.angle += 0.003;
        
        this.rings.forEach((ring, i) => {
            ring.angle += ring.speed;
        });
    }
    
    absorb() {
        // ヒット時の演出用
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.cx, this.cy);
        
        // 1. コアのハロー
        const glowSize = this.radius * 1.1;
        const glowGrad = ctx.createRadialGradient(0, 0, this.radius * 0.5, 0, 0, glowSize);
        glowGrad.addColorStop(0, `rgba(245, 250, 255, 0.4)`);
        glowGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
        ctx.fill();

        // 2. 内部リング（全て時計回り）
        this.rings.forEach((ring, i) => {
            ctx.beginPath();
            ctx.arc(0, 0, ring.r, ring.angle, ring.angle + Math.PI * 1.8); 
            
            ctx.lineWidth = ring.width;
            ctx.lineCap = 'round';
            ctx.strokeStyle = `rgba(180, 200, 220, 0.6)`;
            ctx.stroke();
            
            // アクセント
            const dotX = Math.cos(ring.angle) * ring.r;
            const dotY = Math.sin(ring.angle) * ring.r;
            ctx.beginPath();
            ctx.arc(dotX, dotY, 4, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(150, 180, 200, 0.9)`;
            ctx.fill();
        });

        // 3. メインの外郭
        ctx.rotate(this.angle);
        ctx.beginPath();
        const segments = 8; // 八角形
        for (let i = 0; i < segments; i++) {
            const theta = (i / segments) * Math.PI * 2;
            const x = Math.cos(theta) * this.radius;
            const y = Math.sin(theta) * this.radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        
        ctx.lineWidth = 2;
        ctx.strokeStyle = `rgba(180, 190, 200, 0.8)`;
        ctx.stroke();

        ctx.restore();
    }
}

/**
 * Class: BeamParticle
 */
class BeamParticle {
    constructor(x, y, type, colorStr, velocity) {
        this.x = x;
        this.y = y;
        this.type = type; 
        this.colorStr = colorStr;
        this.velocity = velocity;
        this.life = 1.0;
        this.dead = false;
        
        if (this.type === 0) {
            this.width = 300; // 針の長さを大幅に巨大化
        }
    }

    update() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;

        // 修正: 巨大な針の生成位置(-320px)に対応するため、左側の消滅判定を -500px に緩和
        if (this.x > window.innerWidth + 200 || this.x < -500 || this.y < -200 || this.y > window.innerHeight + 200) {
            this.dead = true;
        }
        
        if (this.type !== 0) {
            this.life -= 0.008; // ゆっくり消える
            if (this.life <= 0) this.dead = true;
        }
    }

    draw(ctx) {
        // Type 0: The Giant Yellow Needle
        if (this.type === 0) {
            ctx.save();
            ctx.translate(this.x, this.y);
            const angle = Math.atan2(this.velocity.y, this.velocity.x);
            ctx.rotate(angle);
            
            // 巨大化した描画
            ctx.beginPath();
            ctx.moveTo(0, 0); 
            ctx.lineTo(-300, 12); // 長さと幅を大きく
            ctx.lineTo(-260, 0); 
            ctx.lineTo(-300, -12); 
            ctx.closePath();
            
            const grad = ctx.createLinearGradient(0, 0, -300, 0);
            grad.addColorStop(0, 'rgba(255, 215, 0, 0.95)'); // Gold
            grad.addColorStop(1, 'rgba(255, 255, 200, 0)');
            ctx.fillStyle = grad;
            
            // 黄色い光彩も少し強く
            ctx.shadowBlur = 20;
            ctx.shadowColor = "rgba(255, 180, 0, 0.6)";
            
            ctx.fill();
            ctx.restore();
            return;
        }

        ctx.beginPath();
        const vLen = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
        const tailLen = (this.type === 2) ? 20 : 15; 
        const safeVLen = vLen || 1; 
        
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(
            this.x - (this.velocity.x / safeVLen) * tailLen, 
            this.y - (this.velocity.y / safeVLen) * tailLen
        );

        ctx.lineCap = 'round';
        ctx.shadowBlur = 0; 
        
        if (this.type === 2) {
            // Feedback: カラフルで、少し太く
            ctx.strokeStyle = `rgba(${this.colorStr}, ${this.life})`; 
            ctx.lineWidth = 2.5;
        } else {
            // Scattered (Type 1): 装置から出る光は少し白っぽく（ニュートラル）
            ctx.strokeStyle = `rgba(${this.colorStr}, ${this.life})`; 
            ctx.lineWidth = 2;
        }

        ctx.stroke();
    }
}

/**
 * Main Application
 */
class App {
    constructor() {
        this.canvas = document.getElementById('heroCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.lens = new Lens(this.width / 2, this.height / 2);
        this.nodes = [];
        this.beams = [];
        
        this.initNodes();
        
        this.loop();
        this.frameCount = 0;
        
        setTimeout(() => this.spawnInputBeam(), 100);
    }

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.initNodes();
    }

    initNodes() {
        this.nodes = [];
        const cols = 9;
        const rows = 14;
        const startX = this.width * 0.6; 
        const startY = this.height * 0.1;
        const gapX = (this.width * 0.35) / cols;
        const gapY = (this.height * 0.8) / rows;

        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                const offsetX = (j % 2 === 0) ? 0 : gapX / 2;
                const noiseX = Utils.random(-3, 3);
                const noiseY = Utils.random(-3, 3);
                
                const x = startX + i * gapX + offsetX + noiseX;
                const y = startY + j * gapY + noiseY;
                
                this.nodes.push(new Node(x, y));
            }
        }
    }

    // 黄色い針
    spawnInputBeam() {
        const startY = this.height / 2;
        const angle = 0; 
        const speed = 3; 
        const velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };

        // Type 0: Needle (Yellow)
        // 針が長くなったので出現位置をさらに左へ
        this.beams.push(new BeamParticle(-320, startY, 0, null, velocity));
    }

    // 針が装置に当たった時：ランダムに50個へ発射
    triggerScatter() {
        // レンズ中心
        const cx = this.width / 2;
        const cy = this.height / 2;

        const targetCount = 50; // 変更: 30 -> 50
        
        // 重複なしで完全にランダムに選ぶため、インデックスをシャッフルする
        const indices = Array.from({length: this.nodes.length}, (_, i) => i);
        // Fisher-Yates Shuffle
        for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
        }

        // シャッフルされた先頭から50個を選ぶ
        for (let i = 0; i < targetCount; i++) {
            if (i >= indices.length) break;
            const targetNode = this.nodes[indices[i]];
            
            // ノードへの角度
            const angle = Math.atan2(targetNode.y - cy, targetNode.x - cx);
            const speed = Utils.random(6, 10); // まあまあゆっくり
            
            const velocity = {
                x: Math.cos(angle) * speed,
                y: Math.sin(angle) * speed
            };
            
            // Type 1: Scattered (薄い黄色〜白で発射)
            this.beams.push(new BeamParticle(cx, cy, 1, '255, 250, 200', velocity));
        }
        
        this.lens.absorb();
    }

    spawnFeedback(node) {
        // ノードからレンズへ戻る
        const dx = (this.width / 2) - node.x;
        const dy = (this.height / 2) - node.y;
        const angle = Math.atan2(dy, dx);
        const speed = Utils.random(7, 12); // まあまあゆっくり戻る
        
        const velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
        
        // Type 2: Feedback (色はノードの色)
        const colorStr = `${Math.floor(node.currentColor.r)}, ${Math.floor(node.currentColor.g)}, ${Math.floor(node.currentColor.b)}`;
        this.beams.push(new BeamParticle(node.x, node.y, 2, colorStr, velocity));
    }

    update() {
        this.frameCount++;
        this.lens.update(this.width / 2, this.height / 2);

        // 5秒に1回 (60fps * 5 = 300)
        if (this.frameCount % 300 === 0) { 
            this.spawnInputBeam();
        }

        for (let i = this.beams.length - 1; i >= 0; i--) {
            const beam = this.beams[i];
            beam.update();

            // 1. NEEDLE hitting Lens
            if (beam.type === 0) {
                const dist = Utils.distance(beam.x, beam.y, this.lens.cx, this.lens.cy);
                if (dist < 30) { 
                    // 針が中心に届いたら散乱開始
                    this.triggerScatter();
                    beam.dead = true;
                }
            } 
            // 2. SCATTERED (Type 1) hitting Nodes
            else if (beam.type === 1) {
                if (beam.x > this.width * 0.5) {
                    for (let node of this.nodes) {
                        const dx = beam.x - node.x;
                        const dy = beam.y - node.y;
                        // 当たり判定
                        if (dx * dx + dy * dy < 400) { 
                            node.hit(); // ノード反応
                            this.spawnFeedback(node); // 跳ね返り生成
                            beam.dead = true; 
                            break; 
                        }
                    }
                }
            }
            // 3. FEEDBACK (Type 2) returning to Lens
            else if (beam.type === 2) {
                const dist = Utils.distance(beam.x, beam.y, this.lens.cx, this.lens.cy);
                if (dist < this.lens.radius * 0.6) {
                    // レンズに戻ったら吸収されて消える
                    beam.dead = true;
                }
            }

            if (beam.dead) {
                this.beams.splice(i, 1);
            }
        }

        this.nodes.forEach(node => node.update());
    }

    draw() {
        this.ctx.clearRect(0, 0, this.width, this.height);

        // ノード
        this.nodes.forEach(node => node.draw(this.ctx));
        
        // ビーム
        this.ctx.globalCompositeOperation = 'source-over';
        this.beams.forEach(beam => beam.draw(this.ctx));

        // レンズ
        this.lens.draw(this.ctx);
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

window.onload = () => {
    new App();
};

</script>
</body>
</html>
